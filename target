#!/bin/bash

#title           	:target
#description     	:Script to make C projects more manageable
#author		 				:Javier Romera Llave @lromeraj
#date            	:20191103
#version         	:1.1.0
#notes           	:Install "figlet" and "valgrind"
#bash_version    	:4.4.19(1)-release
#==============================================================================

# main project dir
MAIN_DIR_NAME=$(basename "$(pwd)" )

declare -A CONFIG

# presets
CONF=./target.conf # configuration file
INCDIRS=() # include dirs
OFILES=() # object files to be linked
ENV="" # global ennvironment

# ascii decorations
ASCII_TITLE=.ascii_title
ASCII_VERSION=.ascii_version


#===== Text decorations =====#
NC='\033[0m'              # Text Reset

# Regular Colors
Black='\033[0;30m'        # Black
Red='\033[0;31m'          # Red
Green='\033[0;32m'        # Green
Yellow='\033[0;33m'       # Yellow
Blue='\033[0;34m'         # Blue
Purple='\033[0;35m'       # Purple
Cyan='\033[0;36m'         # Cyan
White='\033[0;37m'        # White

# Bold
BBlack='\033[1;30m'       # Black
BRed='\033[1;31m'         # Red
BGreen='\033[1;32m'       # Green
BYellow='\033[1;33m'      # Yellow
BBlue='\033[1;34m'        # Blue
BPurple='\033[1;35m'      # Purple
BCyan='\033[1;36m'        # Cyan
BWhite='\033[1;37m'       # White

success()
{
  echo -en "${BGreen}success:${NC} $1" >&1
}

warn()
{
  echo -en "${BYellow}warn:${NC} $1" >&1
}

info()
{
  echo -en "${BCyan}info:${NC} $1" >&1
}

error()
{
  echo -en "${BRed}error:${NC} $1" >&1
}

_fnStart()
{
  echo -en "========== [${BPurple}$ENV${NC}] ${BGreen}$1${NC}\\n" >&1
}

_fnEnd()
{
  echo -en "========== [${BPurple}$ENV${NC}] ${BRed}$1${NC}\\n" >&1
}

_clean()
{

  BUFFER=()
  BUFFER+=( "$TARGET" )

  for m in "${SRCS[@]}"; do
    BUFFER+=( "$OBJDIR/$m.o" )
  done

  _fnStart "CLEAN START"

  for f in "${BUFFER[@]}"; do
    if [ -e "$f" ]; then
      info "removing: ${BYellow}$f${NC}\\n"
      rm -rf "$f"
    else
      info "not found: ${BBlue}$f${NC}\\n"
    fi
  done

  _fnEnd "CLEAN END"

}

_link()
{

  OFILES=()

  for f in "${SRCS[@]}"; do
    if [[ -e "$OBJDIR/$f.o" ]]; then
      OFILES+=( "$OBJDIR/$f.o" )
    fi
  done

	gcc "${OFILES[@]}" ${LDFLAGS[@]} -o $TARGET

  return $?
}

# time of last data modification, seconds since Epoch
_modDate()
{
	stat -L -c %Y "$1"
}

_date()
{
  date '+%Y%d%m'
}

# finds a version inside a file
_findV()
{
  grep -Po -m1 'v[0-9].*' "$1"
}

_avai()
{
  command -v "$1"
}

env_get()
{

  _env=""
  found=false

  reg1="^\\[$ENV\\]"
  reg2="^\\[(.*)\\]"

  f=0
  arr=()
  buff=()
  isStr=0
  end=false

  while read -r line; do

    # detect env [env]
    if [[ -z $_env ]]; then
      if [[ $line =~ $reg1 ]]; then
        _env=${BASH_REMATCH[0]}
      fi
      continue;
    else
      if [[ $line =~ $reg2 ]]; then
        break;
      fi
    fi

    # parse line
    for (( i=0; i<${#line}; i++ )); do

      c="${line:$i:1}"

      addChar=true

      case $c in

        "#")
          break
        ;;

        "=")
          f=1
          addChar=false
        ;;

        "[")
          f=3
          addChar=false
        ;;

        '"')
          isStr=$(( 1 - isStr ))
          if [ $isStr -eq 0 ]; then end=true; fi
          addChar=false
        ;;

        "]")
          f=4
          addChar=false
        ;;
      esac

      if [[ $c == " " ]]; then
        addChar=false
      fi

      if [ $isStr -eq 1 ] && [[ $c != '"' ]]; then
        addChar=true
      fi

      case $f in

        1)
          if [[ "${buff[0]}" == "$1" ]]; then
            found=true
          else break; fi
        ;;

        3)
          if [[ $c == "," ]] && [[ -n ${buff[ $f ]} ]]; then
            arr+=( "${buff[ $f ]}" )
            buff[ $f ]=""
            addChar=false
          fi
        ;;

        4)
          arr+=( "${buff[ 3 ]}" )
          end=true
          break;
        ;;

      esac

      if [ $addChar == true ]; then
        buff[ $f ]+=$c;
      fi

    done

    if [ $f == 1 ] && [ ${#buff[1]} -ne 0 ]; then end=true; fi

    if [ $found == true ] && [ $end == true ]; then

      if [ $f -eq 1 ]; then
        echo "${buff[1]}" >&1
      elif [ $f -eq 4 ]; then
        echo "${arr[*]}" >&1
      fi
      break;
    elif [ $found == false ]; then
      f=0
      buff=()
      end=false
    fi

  done < $CONF

}



env_load()
{

  _env=""
  found=false

  reg1="^\\[$ENV\\]"
  reg2="^\\[(.*)\\]"

  f=0
  arr=()
  buff=()
  isStr=0
  end=false

  while read -r line; do

    # detect env [env]
    if [[ -z $_env ]]; then
      if [[ $line =~ $reg1 ]]; then
        _env=${BASH_REMATCH[0]}
      fi
      continue;
    else
      if [[ $line =~ $reg2 ]]; then
        break;
      fi
    fi

    # parse line
    for (( i=0; i<${#line}; i++ )); do

      c="${line:$i:1}"

      addChar=true

      case $c in

        "#")
          break
        ;;

        "=")
          f=1
          addChar=false
        ;;

        "[")
          f=3
          addChar=false
        ;;

        '"')
          isStr=$(( 1 - isStr ))
          if [ $isStr -eq 0 ]; then end=true; fi
          addChar=false
        ;;

        "]")
          f=4
          addChar=false
        ;;
      esac

      if [[ $c == " " ]]; then
        addChar=false
      fi

      if [ $isStr -eq 1 ] && [[ $c != '"' ]]; then
        addChar=true
      fi

      case $f in

        1)
          if [[ "${buff[0]}" == "$1" ]]; then
            found=true
          fi
        ;;

        3)
          if [[ $c == "," ]] && [[ -n ${buff[ $f ]} ]]; then
            arr+=( "${buff[ $f ]}" )
            buff[ $f ]=""
            addChar=false
          fi
        ;;

        4)
          arr+=( "${buff[ 3 ]}" )
          end=true
        ;;

      esac

      if [ $addChar == true ]; then
        buff[ $f ]+=$c;
      fi

    done

    if [ $f -eq 1 ] && [ $isStr -eq 0 ]; then end=true; fi

    if [ $end == true ]; then

      if [ $f -eq 1 ]; then
        arr[0]=${buff[1]};
      fi

      CONFIG[${buff[0]}]="${arr[@]}"

      f=0
      arr=()
      buff=()
      end=false
    fi

  done < $CONF

  TARGET=$( _conf "TARGET" )
  TARGET_ARGS=( $( _conf "TARGET_ARGS" ) )
  SRCDIR=$( _conf "SRCDIR" )
  SRCS=( $( _conf "SRCS" ) )
  OBJDIR=$( _conf "OBJDIR" )
  INCDIR=$( _conf "INCDIR" )
  DISTDIR=$( _conf "DISTDIR" )
  CFLAGS=( $( _conf "CFLAGS" ) )
  LDFLAGS=( $( _conf "LDFLAGS" ) )
  CLOG=$( _conf "CLOG" )
  ASCII_VERSION=$( _conf "ASCII_VERSION" )
  ASCII_TITLE=$( _conf "ASCII_TITLE" )

}


_notDef()
{
  error "\$$1 is not defined\\n"
  return 0
}

_notFnd()
{
  error "'$1': no such file or directory\\n"
  return 0
}

# compiles a given dir
_comp()
{

  errc=0

  if [[ -z "$TARGET" ]]; then
    _notDef "TARGET"; errc=1
  fi

  if [[ -z "$OBJDIR" ]]; then
    _notDef "OBJDIR"; errc=1
  elif [[ ! -d "$OBJDIR" ]]; then
    _notFnd "$OBJDIR"; errc=1
  fi

  if [[ -z "$INCDIR" ]]; then
    _notDef "INCDIR"; errc=1
  elif [[ ! -d "$INCDIR" ]]; then
    _notFnd "$INCDIR"; errc=1
  fi

  if [[ -z "$SRCDIR" ]]; then
    _notDef "SRCDIR"; errc=1
  elif [[ ! -d "$SRCDIR" ]]; then
    _notFnd "$SRCDIR"; errc=1
  fi

  if [ $errc -ne 0 ]; then return $errc; fi

  if [ -d "${SRCDIR}" ]; then

    # modules
    for re in "${SRCS[@]}"; do

      FILES=()
      cit=false # compilation flag
      c_file="$SRCDIR/$re.c"
      h_file="$INCDIR/$re.h"
      o_file="$OBJDIR/$re.o"
      FILES+=( "$c_file" )
      FILES+=( "$h_file" )

      for f in "${FILES[@]}"; do

        fname=$(basename -- "$f")
        ext=${fname##*.}

        if [ ! -e "$f" ]; then

          if [ "$f" == "$c_file" ]; then
            error "no such file: ${BRed}$c_file${NC}\\n"
            return 1
          fi

          continue;

        fi

  			if [ -e "$TARGET" ]; then
  				if [ -e "$o_file" ]; then
  					if [ "$(_modDate "$TARGET" )" -lt "$(_modDate "$f" )" ]; then
  						cit=true
  					fi
          else
            cit=true
          fi
  			else
          cit=true
        fi

      done

      if [ $cit == true ] && [[ -e $c_file ]]; then
        info "compiling: ${BYellow}$c_file${NC} -> $o_file\\n"
        gcc ${CFLAGS[@]} -I${INCDIR} -c $c_file -o $o_file
      else
        info "up to date: ${BGreen}$c_file${NC} -> $o_file\\n"
      fi

    done

	else
		error "${Yellow}$SRCDIR${NC}: no such directory\\n"
		return 1
	fi

}

_conf()
{
  echo ${CONFIG[$1]}
}

# check if there are as least 1 argument
if [ $# -lt 1 ]; then
	error "too few args\\n"
	exit 1
fi

# load configuration file
if [[ ! -e "$CONF" ]]; then
  error "$CONF: no such file\\n"
  exit 1
else
  ENV="GLOBAL"
  env_load
fi

while [ $# -gt 0 ]; do

  case $1 in

    -e|--env)

      reg="^-"
      if [[ $2 =~ $reg ]] || [[ -z $2 ]]; then

        error "env: too few args\\n"
        shift
      else
        grep -Pq "^\\[$2\\]" $CONF
        if [[ $? -eq 0 ]]; then
          ENV="$2"

          env_load

          shift 2
        else

          reg="^-e|^--env"
          error "env: [$2] not found\\n"
          shift 2
          while  [ $# -gt 0 ]; do
            if [[ $1 =~ $reg ]]; then break; fi
            shift
          done

        fi

      fi

    ;;

    -c|--comp)

      ASCII_TITLE=$( _conf "ASCII_TITLE" )
      ASCII_VERSION=$( _conf "ASCII_VERSION" )

      if [ -e "$ASCII_TITLE" ]; then
        echo -e "${BPurple}$( cat "$ASCII_TITLE" )${NC}"
      fi

      if [ -e "$ASCII_VERSION" ]; then
        echo -e "${BYellow}$( cat "$ASCII_VERSION" )${NC}"
      fi

      _fnStart "COMPILATION START"
      _comp
      if [ $? -eq 0 ]; then
        _link
        if [ $? -ne 0 ]; then
          error "link failed\\n"
        else
          success "link success -> ${BCyan}${TARGET}${NC}\\n"
        fi
      else
        error "compilation failed\\n"
      fi

      _fnEnd "COMPILATION END"

      shift 1

    ;;

    -d|--dist)

      name="${TARGET}_$(_date).zip"

      if [[ -e $CLOG ]]; then

        _v=$( _findV "$CLOG" ) # find last version

        if [[ ! -z $_v ]]; then

          name="${TARGET}_${_v}_$(_date).zip"

          if [[ -n $( _avai figlet ) ]]; then
            echo "" > "$ASCII_VERSION"
            figlet "${_v}" >> "$ASCII_VERSION"
          fi

        fi

      fi

      _fnStart "DIST START"

      # go to parent dir
      cd ..

      # zip the main project dir
      zip --symlinks -r "$name" "$MAIN_DIR_NAME" -x "*.o" "*.zip"

      # move the file inside the project dir again
      mv "$name" "$MAIN_DIR_NAME"

      # cd to the main dir
      cd "$MAIN_DIR_NAME"

      _fnEnd "DIST END"

      if [[ -d ${DISTDIR} ]]; then
        mv "$name" "$DISTDIR"
      elif [[ -n $DISTDIR ]]; then
        warn "dist: '$DISTDIR': no such directory\\n"
      fi

      shift 1

    ;;

    -r|--run)

      _ARGS=()

      _fnStart "RUN START"

      if [[ -e ${TARGET} ]]; then

        reg="^-e|^--env"
        shift

        while [[ $# -gt 0 ]]; do
          if [[ $1 =~ $reg ]]; then break;
          else
            _ARGS+=( "$1" )
            shift
          fi
        done


        if [ ${#_ARGS[@]} -gt 0 ]; then
          "./${TARGET}" "${_ARGS[@]}"
        else
          "./${TARGET}" "${TARGET_ARGS[@]}"
        fi


      else
        warn "run: not compiled yet\\n"
        shift 1
      fi

      _fnEnd "RUN END"

    ;;

    -m|--cmem)

      if [[ -e "${TARGET}" ]]; then

        reg="^-e|^--env"
        shift

        while [[ $# -gt 0 ]]; do
          if [[ $1 =~ $reg ]]; then break;
          else
            _ARGS+=( "$1" )
            shift
          fi
        done

        if [[ -n "$( _avai valgrind )" ]]; then

          if [ ${#_ARGS[@]} -gt 0 ]; then
            valgrind ${VGR_FLAGS} "./${TARGET}" "${_ARGS[@]}"
          else
            valgrind ${VGR_FLAGS} "./${TARGET}" "${TARGET_ARGS[@]}"
          fi

        else
          error "valgrind: command not found\n"
        fi

      else
        warn "cmem: not compiled yet\\n"
      fi

    ;;

    --clean)
      _clean
      shift 1
    ;;

    -h|--help)

      shift 1
      break;
    ;;

    *)
      error "$1: unknown option\\n"
      shift 1
    ;;

  esac

done
